from __future__ import annotations

import dataclasses
import functools


@dataclasses.dataclass(frozen=True)
class UnwrappedConfigStringPart:
    level: int
    opening_index: int
    operator: str
    hyperparameters: str
    operands: str


@functools.lru_cache(maxsize=2000)
def unwrap_config_string(config_string: str) -> tuple[UnwrappedConfigStringPart]:
    """
    For a given config string, gets the parenthetic contents of it
    and uses them to construct objects of type `UnwrappedConfigStringPart`.

    First unwraps a given parenthesised config_string into parts.
    Then it converts these parts into objects with structured information.
    """

    # A workaround needed since in the existing configurations
    #  generated by previous methods, e.g. the `resBlock resBlock` and `resBlock` items
    #  occur without wrapping parenthesis, differently from other items.
    # Wrap them appropriately in parentheses here and in the inverse process.
    # For example 'id' comes in two forms: 'id id' and 'Ops id',
    #  only the 'id id' variant should be replaced.
    replacements = [
        ("resBlock", True),
        ("id", False),
    ]
    for op, replace_individual in replacements:
        config_string = config_string.replace(f"{op} {op}", "__TMP_PLACEHOLDER___")
        if replace_individual:
            config_string = config_string.replace(f"{op}", f"({op})")
        config_string = config_string.replace("__TMP_PLACEHOLDER___", f"({op} {op})")

    result = []

    stack = []
    opening_counter = 0
    for current_char_index, current_char in enumerate(config_string):
        if current_char == "(":
            stack.append((current_char_index, opening_counter))
            opening_counter += 1
        elif current_char == ")":
            assert stack, f"Found ')' with no matching '('. Index: {current_char_index}"

            start_char_index, opening_index = stack.pop()
            level = len(stack) + 1  # start level counting from 1 and not 0

            value = config_string[start_char_index + 1 : current_char_index]
            value = value.split(" (", maxsplit=1)
            operator = value[0]
            if len(value) > 1:
                operands = "(" + value[1]
            else:
                operands = ""

            if " {" in operator:
                operator, hyperparameters = operator.split(" {")
                hyperparameters = "{" + hyperparameters
            else:
                hyperparameters = "{}"

            item = UnwrappedConfigStringPart(
                level=level,
                opening_index=opening_index,
                operator=operator,
                hyperparameters=hyperparameters,
                operands=operands,
            )
            result.append(item)

    assert not stack, f"For '(' found no matching ')': Index: {stack[0][0]}"
    result = tuple(sorted(result, key=lambda x: x.opening_index))
    return result


# Current profiling shows this function does not run that often
#  so no need for caching
def wrap_config_into_string(
    unwrapped_config: tuple[UnwrappedConfigStringPart, ...],
    max_level: int | None = None,
) -> str:
    """
    For a given unwrapped config, returns the string representing it.
    :param unwrapped_config: The unwrapped config
    :param max_level:
        An optional int telling which is the maximal considered level.
        Bigger levels are ignored
    """
    result = []
    current_level = 0
    for item in unwrapped_config:
        if max_level is not None and item.level > max_level:
            continue

        if item.level > current_level:
            if item.hyperparameters not in ("{}", ""):
                value = " (" + str(item.operator) + " " + item.hyperparameters
            else:
                value = " (" + str(item.operator)
        elif item.level < current_level:
            value = ")" * (current_level - item.level + 1) + " (" + str(item.operator)
        else:
            value = ") (" + str(item.operator)
        current_level = item.level
        result.append(value)
    result.append(")" * current_level)

    result = "".join(result).strip()

    # A workaround needed since in the existing configurations
    #  generated by previous methods, e.g. the `resBlock resBlock` and `resBlock` items
    #  occur without wrapping parenthesis, differently from other items.
    # Wrap them appropriately in parentheses here and in the inverse process.
    # For example 'id' comes in two forms: 'id id' and 'Ops id',
    #  only the 'id id' variant should be replaced.
    replacements = [
        ("resBlock", True),
        ("id", False),
    ]
    for op, replace_individual in replacements:
        result = result.replace(f"({op} {op})", "__TMP_PLACEHOLDER___")
        if replace_individual:
            result = result.replace(f"({op})", f"{op}")
        result = result.replace("__TMP_PLACEHOLDER___", f"{op} {op}")

    return result


class ConfigString:
    def __init__(self, config_string: str) -> None:
        if config_string is None or len(config_string) == 0:
            raise ValueError(f"Invalid config string: {config_string}")
        self.config_string = config_string

        # The fields below are needed for lazy and cached evaluation.
        # In python 3.8+ can be replaced by `cached_property`
        self._unwrapped: tuple[UnwrappedConfigStringPart] | None = None
        self._max_hierarchy_level: int | None = None

        # a cache for the different hierarchy levels of this config string
        self._at_hierarchy_level_cache: dict[int, ConfigString] = {}

    @property
    def unwrapped(self) -> tuple[UnwrappedConfigStringPart]:
        if self._unwrapped is not None:
            return self._unwrapped

        unwrapped = unwrap_config_string(self.config_string)
        if not unwrapped:
            raise ValueError(f"Error unwrapping config string: {self.config_string}")

        # NOTE: slow test that can possibly be removed
        #  test that meaning was preserved between wrapping and unwrapping
        #  to make sure the config string wrapping/unwrapping is working well
        rewrapped_config = wrap_config_into_string(unwrapped_config=unwrapped)
        assert self.config_string == rewrapped_config, (
            "Error during wrapping unwrapping: config_string != rewrapped_config_string",
            self.config_string,
            rewrapped_config,
        )

        self._unwrapped = unwrapped
        return self._unwrapped

    @property
    def max_hierarchy_level(self) -> int:
        if self._max_hierarchy_level is not None:
            return self._max_hierarchy_level

        max_hierarchy_level = max(i.level for i in self.unwrapped)
        assert max_hierarchy_level > 0, f"Invalid max hierarchy level: {self.max_hierarchy_level}"

        self._max_hierarchy_level = max_hierarchy_level
        return self._max_hierarchy_level

    def at_hierarchy_level(self, level: int) -> ConfigString:
        """
        Get a representation of this config at the chosen hierarchy level.
        :param level:
            When >0, get the config the that hierarchy level.
            When <0, get the config at (max_hierarchy_level - level + 1),
             similar to negative python indices in e.g. lists.
        :return:
        """
        if level == 0:
            raise ValueError(f"Invalid value for `level`. Received level == 0: {level}")
        if level > self.max_hierarchy_level:
            raise ValueError(
                "Invalid value for `level`. " + f"level>max_hierarchy_level: {level}>{self.max_hierarchy_level}"
            )
        if level < -self.max_hierarchy_level:
            raise ValueError(
                "Invalid value for `level`. " + f"level<-max_hierarchy_level: {level}<-{self.max_hierarchy_level}"
            )

        if level < 0:
            # for example for level=-1, when max_hierarchy_level=7, new level is 7
            # for example for level=-3, when max_hierarchy_level=7, new level is 5
            level = self.max_hierarchy_level + (level + 1)

        if level in self._at_hierarchy_level_cache:
            return self._at_hierarchy_level_cache[level]

        config_string_at_hierarchy_level = wrap_config_into_string(unwrapped_config=self.unwrapped, max_level=level)
        config_at_hierarchy_level = ConfigString(config_string_at_hierarchy_level)
        self._at_hierarchy_level_cache[level] = config_at_hierarchy_level

        return self._at_hierarchy_level_cache[level]

    def pretty_format(self) -> str:
        format_str_with_kwargs = "{indent}{item.level:0>2d} :: {item.operator} {item.hyperparameters}"
        format_str_no_kwargs = "{indent}{item.level:0>2d} :: {item.operator}"
        lines = [self.config_string]
        for item in self.unwrapped:
            if item.hyperparameters not in {"{}", ""}:
                line = format_str_with_kwargs.format(item=item, indent="\t" * item.level)
            else:
                line = format_str_no_kwargs.format(item=item, indent="\t" * item.level)
            lines.append(line)
        return "\n".join(lines)

    def __eq__(self, other: object) -> bool:
        if isinstance(other, self.__class__):
            return self.config_string == other.config_string
        raise NotImplementedError()  # let the other side check for equality

    def __ne__(self, other: object) -> bool:
        return not self.__eq__(other)

    def __hash__(self) -> int:
        return self.config_string.__hash__()
