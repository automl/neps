"""This module provides functionality to unwrap and wrap configuration strings
used in NePS spaces. It defines the `UnwrappedConfigStringPart` data class
to represent parts of the unwrapped configuration string and provides
functions to unwrap a configuration string into these parts and to wrap
unwrapped parts back into a configuration string.
"""

from __future__ import annotations

import dataclasses
import functools
from collections.abc import Callable
from typing import Any


@dataclasses.dataclass(frozen=True)
class UnwrappedConfigStringPart:
    """A data class representing a part of an unwrapped configuration string.
    :param level: The hierarchy level of this part in the configuration string.
    :param opening_index: The index of the opening parenthesis in the original string.
    :param operator: The operator of this part, which is the first word in the
    parenthesis.
    :param hyperparameters: The hyperparameters of this part, if any, enclosed in curly
    braces.
    :param operands: The operands of this part, which are the remaining content in the
    parenthesis.
    """

    level: int
    opening_index: int
    operator: str | Callable[..., Any]
    hyperparameters: str
    operands: str


@functools.lru_cache(maxsize=2000)
def unwrap_config_string(config_string: str) -> tuple[UnwrappedConfigStringPart, ...]:
    """For a given config string, gets the parenthetic contents of it
    and uses them to construct objects of type `UnwrappedConfigStringPart`.

    First unwraps a given parenthesised config_string into parts.
    Then it converts these parts into objects with structured information.
    """
    # A workaround needed since in the existing configurations
    #  generated by previous methods, e.g. the `resBlock resBlock` and `resBlock` items
    #  occur without wrapping parenthesis, differently from other items.
    # Wrap them appropriately in parentheses here and in the inverse process.
    # For example 'id' comes in two forms: 'id id' and 'Ops id',
    #  only the 'id id' variant should be replaced.
    replacements = [
        ("resBlock", True),
        ("id", False),
    ]
    for op, replace_individual in replacements:
        config_string = config_string.replace(f"{op} {op}", "__TMP_PLACEHOLDER___")
        if replace_individual:
            config_string = config_string.replace(f"{op}", f"({op})")
        config_string = config_string.replace("__TMP_PLACEHOLDER___", f"({op} {op})")

    result = []

    stack = []
    opening_counter = 0
    for current_char_index, current_char in enumerate(config_string):
        if current_char == "(":
            stack.append((current_char_index, opening_counter))
            opening_counter += 1
        elif current_char == ")":
            assert stack, f"Found ')' with no matching '('. Index: {current_char_index}"

            start_char_index, opening_index = stack.pop()
            level = len(stack) + 1  # start level counting from 1 and not 0

            value_single = config_string[start_char_index + 1 : current_char_index]
            value = value_single.split(" (", maxsplit=1)
            operator = value[0]
            operands = "(" + value[1] if len(value) > 1 else ""

            if " {" in operator:
                operator, hyperparameters = operator.split(" {")
                hyperparameters = "{" + hyperparameters
            else:
                hyperparameters = "{}"

            item = UnwrappedConfigStringPart(
                level=level,
                opening_index=opening_index,
                operator=operator,
                hyperparameters=hyperparameters,
                operands=operands,
            )
            result.append(item)

    assert not stack, f"For '(' found no matching ')': Index: {stack[0][0]}"
    return tuple(sorted(result, key=lambda x: x.opening_index))


# Current profiling shows this function does not run that often
#  so no need for caching
def wrap_config_into_string(
    unwrapped_config: tuple[UnwrappedConfigStringPart, ...],
    max_level: int | None = None,
) -> str:
    """For a given unwrapped config, returns the string representing it.
    :param unwrapped_config: The unwrapped config
    :param max_level:
        An optional int telling which is the maximal considered level.
        Bigger levels are ignored.
    """
    result = []
    current_level = 0
    for item in unwrapped_config:
        if max_level is not None and item.level > max_level:
            continue

        if item.level > current_level:
            if item.hyperparameters not in ("{}", ""):
                value = " (" + str(item.operator) + " " + item.hyperparameters
            else:
                value = " (" + str(item.operator)
        elif item.level < current_level:
            value = ")" * (current_level - item.level + 1) + " (" + str(item.operator)
        else:
            value = ") (" + str(item.operator)
        current_level = item.level
        result.append(value)
    result.append(")" * current_level)

    result_string = "".join(result).strip()

    # A workaround needed since in the existing configurations
    #  generated by previous methods, e.g. the `resBlock resBlock` and `resBlock` items
    #  occur without wrapping parenthesis, differently from other items.
    # Wrap them appropriately in parentheses here and in the inverse process.
    # For example 'id' comes in two forms: 'id id' and 'Ops id',
    #  only the 'id id' variant should be replaced.
    replacements = [
        ("resBlock", True),
        ("id", False),
    ]
    for op, replace_individual in replacements:
        result_string = result_string.replace(f"({op} {op})", "__TMP_PLACEHOLDER___")
        if replace_individual:
            result_string = result_string.replace(f"({op})", f"{op}")
        result_string = result_string.replace("__TMP_PLACEHOLDER___", f"{op} {op}")

    return result_string


class ConfigString:
    """A class representing a configuration string in NePS spaces.
    It provides methods to unwrap the configuration string into structured parts,
    retrieve the maximum hierarchy level, and get a representation of the configuration
    at a specific hierarchy level.
    """

    def __init__(self, config_string: str) -> None:
        """Initialize the ConfigString with a given configuration string.
        :param config_string: The configuration string to be wrapped.
        :raises ValueError: If the config_string is None or empty.
        """
        if config_string is None or len(config_string) == 0:
            raise ValueError(f"Invalid config string: {config_string}")
        self.config_string = config_string

        # The fields below are needed for lazy and cached evaluation.
        # In python 3.8+ can be replaced by `cached_property`
        self._unwrapped: tuple[UnwrappedConfigStringPart, ...] | None = None
        self._max_hierarchy_level: int | None = None

        # a cache for the different hierarchy levels of this config string
        self._at_hierarchy_level_cache: dict[int, ConfigString] = {}

    @property
    def unwrapped(self) -> tuple[UnwrappedConfigStringPart, ...]:
        """Get the unwrapped representation of the configuration string.
        :return: A tuple of UnwrappedConfigStringPart objects representing the unwrapped
        config.
        :raises ValueError: If there is an error unwrapping the config string.
        """
        # If the unwrapped is already cached, return it
        if self._unwrapped is not None:
            return self._unwrapped

        unwrapped = unwrap_config_string(self.config_string)
        if not unwrapped:
            raise ValueError(f"Error unwrapping config string: {self.config_string}")

        # NOTE: slow test that can possibly be removed
        #  test that meaning was preserved between wrapping and unwrapping
        #  to make sure the config string wrapping/unwrapping is working well
        rewrapped_config = wrap_config_into_string(unwrapped_config=unwrapped)
        assert self.config_string == rewrapped_config, (
            "Error during wrapping unwrapping: config_string != rewrapped_config_string",
            self.config_string,
            rewrapped_config,
        )

        self._unwrapped = unwrapped
        return self._unwrapped

    @property
    def max_hierarchy_level(self) -> int:
        """Get the maximum hierarchy level of the configuration string.
        :return: The maximum hierarchy level of the configuration string.
        :raises ValueError: If the maximum hierarchy level is invalid.
        """
        if self._max_hierarchy_level is not None:
            return self._max_hierarchy_level

        max_hierarchy_level = max(i.level for i in self.unwrapped)
        assert max_hierarchy_level > 0, (
            f"Invalid max hierarchy level: {self.max_hierarchy_level}"
        )

        self._max_hierarchy_level = max_hierarchy_level
        return self._max_hierarchy_level

    def at_hierarchy_level(self, level: int) -> ConfigString:
        """Get the configuration string at a specific hierarchy level.
        :param level: The hierarchy level to retrieve the configuration string for.
        :return: A ConfigString object representing the configuration at the specified
        hierarchy level.
        :raises ValueError: If the level is invalid (0 or out of bounds).
        """
        if level == 0:
            raise ValueError(f"Invalid value for `level`. Received level == 0: {level}")
        if level > self.max_hierarchy_level:
            raise ValueError(
                "Invalid value for `level`. "
                + f"level>max_hierarchy_level: {level}>{self.max_hierarchy_level}"
            )
        if level < -self.max_hierarchy_level:
            raise ValueError(
                "Invalid value for `level`. "
                + f"level<-max_hierarchy_level: {level}<-{self.max_hierarchy_level}"
            )

        if level < 0:
            # for example for level=-1, when max_hierarchy_level=7, new level is 7
            # for example for level=-3, when max_hierarchy_level=7, new level is 5
            level = self.max_hierarchy_level + (level + 1)

        if level in self._at_hierarchy_level_cache:
            return self._at_hierarchy_level_cache[level]

        config_string_at_hierarchy_level = wrap_config_into_string(
            unwrapped_config=self.unwrapped, max_level=level
        )
        config_at_hierarchy_level = ConfigString(config_string_at_hierarchy_level)
        self._at_hierarchy_level_cache[level] = config_at_hierarchy_level

        return self._at_hierarchy_level_cache[level]

    def pretty_format(self) -> str:
        """Get a pretty formatted string representation of the configuration string.
        :return: A string representation of the configuration string with indentation
        based on the hierarchy level of each part.
        """
        format_str_with_kwargs = (
            "{indent}{item.level:0>2d} :: {item.operator} {item.hyperparameters}"
        )
        format_str_no_kwargs = "{indent}{item.level:0>2d} :: {item.operator}"
        lines = [self.config_string]
        for item in self.unwrapped:
            if item.hyperparameters not in {"{}", ""}:
                line = format_str_with_kwargs.format(item=item, indent="\t" * item.level)
            else:
                line = format_str_no_kwargs.format(item=item, indent="\t" * item.level)
            lines.append(line)
        return "\n".join(lines)

    def __eq__(self, other: object) -> bool:
        if isinstance(other, self.__class__):
            return self.config_string == other.config_string
        raise NotImplementedError()  # let the other side check for equality

    def __ne__(self, other: object) -> bool:
        return not self.__eq__(other)

    def __hash__(self) -> int:
        return self.config_string.__hash__()
