"""This module provides functionality to unwrap and wrap configuration strings
used in NePS spaces. It defines the `UnwrappedConfigStringPart` data class
to represent parts of the unwrapped configuration string and provides
functions to unwrap a configuration string into these parts and to wrap
unwrapped parts back into a configuration string.
"""

from __future__ import annotations

import dataclasses
import functools
from collections.abc import Callable
from typing import Any


@dataclasses.dataclass(frozen=True)
class UnwrappedConfigStringPart:
    """A data class representing a part of an unwrapped configuration string.

    Args:
        level: The hierarchy level of this part in the configuration string.
        opening_index: The index of the opening parenthesis in the original string.
        operator: The operator of this part, which is the first word in the
            parenthesis.
        hyperparameters: The hyperparameters of this part, if any, enclosed in curly
            braces.
        operands: The operands of this part, which are the remaining content in the
            parenthesis.
    """

    level: int
    opening_index: int
    operator: str | Callable[..., Any]
    hyperparameters: str
    operands: str


@functools.lru_cache(maxsize=2000)
def unwrap_config_string(config_string: str) -> tuple[UnwrappedConfigStringPart, ...]:
    """For a given config string, gets the parenthetic contents of it
    and uses them to construct objects of type `UnwrappedConfigStringPart`.
    First unwraps a given parenthesised config_string into parts.
    Then it converts these parts into objects with structured information.

    Args:
        config_string: The configuration string to be unwrapped.

    Returns:
        A tuple of `UnwrappedConfigStringPart` objects representing the unwrapped
        configuration string.
    """
    # Handle simple strings with no parentheses
    if "(" not in config_string:
        # This is a simple operator name with no nested structure
        # Create a single unwrapped part for it
        item = UnwrappedConfigStringPart(
            level=1,
            opening_index=0,
            operator=config_string.strip(),
            hyperparameters="{}",
            operands="",
        )
        return (item,)

    # A workaround needed since in the existing configurations
    #  generated by previous methods, e.g. the `resBlock resBlock` and `resBlock` items
    #  occur without wrapping parenthesis, differently from other items.
    # Wrap them appropriately in parentheses here and in the inverse process.
    # For example 'id' comes in two forms: 'id id' and 'Ops id',
    #  only the 'id id' variant should be replaced.
    replacements = [
        ("resBlock", True),
        ("id", False),
    ]
    for op, replace_individual in replacements:
        config_string = config_string.replace(f"{op} {op}", "__TMP_PLACEHOLDER___")
        if replace_individual:
            config_string = config_string.replace(f"{op}", f"({op})")
        config_string = config_string.replace("__TMP_PLACEHOLDER___", f"({op} {op})")

    result = []

    stack = []
    opening_counter = 0
    for current_char_index, current_char in enumerate(config_string):
        if current_char == "(":
            stack.append((current_char_index, opening_counter))
            opening_counter += 1
        elif current_char == ")":
            assert stack, f"Found ')' with no matching '('. Index: {current_char_index}"

            start_char_index, opening_index = stack.pop()
            level = len(stack) + 1  # start level counting from 1 and not 0

            # Extract the content between the matching parentheses
            content_inside_parens = config_string[
                start_char_index + 1 : current_char_index
            ]

            # Find the operator name by looking backwards from the opening parenthesis
            # to find where the operator name starts (either start of string, or after a
            # comma/space)
            operator_start = start_char_index - 1
            while operator_start >= 0 and config_string[operator_start] not in ",(":
                operator_start -= 1
            operator_start += 1  # Move forward to the first character of the operator

            operator = config_string[operator_start:start_char_index]
            operands = content_inside_parens

            # Handle hyperparameters enclosed in curly braces
            if " {" in operator:
                operator, hyperparameters = operator.split(" {", maxsplit=1)
                hyperparameters = "{" + hyperparameters
            else:
                hyperparameters = "{}"

            item = UnwrappedConfigStringPart(
                level=level,
                opening_index=opening_index,
                operator=operator,
                hyperparameters=hyperparameters,
                operands=operands,
            )
            result.append(item)

    assert not stack, f"For '(' found no matching ')': Index: {stack[0][0]}"
    return tuple(sorted(result, key=lambda x: x.opening_index))


# Current profiling shows this function does not run that often
#  so no need for caching
def wrap_config_into_string(  # noqa: C901, PLR0915
    unwrapped_config: tuple[UnwrappedConfigStringPart, ...],
    max_level: int | None = None,
) -> str:
    """For a given unwrapped config, returns the string representing it.

    Args:
        unwrapped_config: The unwrapped config
        max_level: An optional int telling which is the maximal considered level.
            Bigger levels are ignored.

    Returns:
        The string representation of the unwrapped config.
    """
    if not unwrapped_config:
        return ""

    # Build a tree structure from the unwrapped parts
    # Group children by their parent's (level, opening_index)
    children_by_parent: dict[tuple[int, int], list[UnwrappedConfigStringPart]] = {}
    for item in unwrapped_config:
        if max_level is not None and item.level > max_level:
            continue
        parent_key = (
            (item.level - 1, item.opening_index - 1) if item.level > 1 else (0, -1)
        )
        if parent_key not in children_by_parent:
            children_by_parent[parent_key] = []
        children_by_parent[parent_key].append(item)

    def reconstruct(item: UnwrappedConfigStringPart) -> str:  # noqa: C901, PLR0912
        """Recursively reconstruct the config string for an item."""
        operator_name = (
            item.operator.__name__ if callable(item.operator) else item.operator
        )

        # Get children of this item
        item_key = (item.level, item.opening_index)
        children = children_by_parent.get(item_key, [])

        # Reconstruct operands
        if not item.operands and not children:
            # No operands at all - just return the operator name
            return operator_name
        if not children:
            # Leaf node - just wrap the operands
            return f"{operator_name}({item.operands})"
        # Has children - need to mix nested and non-nested operands
        # Parse operands to separate nested from non-nested
        parts = []
        if item.operands:
            current_part = []  # type: ignore[var-annotated]
            paren_depth = 0
            for char in item.operands:
                if char == "(":
                    paren_depth += 1
                elif char == ")":
                    paren_depth -= 1
                elif char == "," and paren_depth == 0:
                    parts.append("".join(current_part).strip())
                    current_part = []
                    continue
                current_part.append(char)
            if current_part:
                parts.append("".join(current_part).strip())

        # Reconstruct each part - nested ones recursively, non-nested as-is
        reconstructed_parts = []
        child_idx = 0
        for part in parts:
            if "(" in part:
                # This is a nested structure - should have a corresponding child
                if child_idx < len(children):
                    reconstructed_parts.append(reconstruct(children[child_idx]))
                    child_idx += 1
                else:
                    # Shouldn't happen, but fallback
                    reconstructed_parts.append(part)
            else:
                # Non-nested operand - just add it
                reconstructed_parts.append(part)

        # Add any remaining children that weren't referenced in operands
        while child_idx < len(children):
            reconstructed_parts.append(reconstruct(children[child_idx]))
            child_idx += 1

        return f"{operator_name}({', '.join(reconstructed_parts)})"

    # Start reconstruction from the root (level 1 items)
    root_items = [item for item in unwrapped_config if item.level == 1]
    if not root_items:
        return ""

    # If there's only one root, reconstruct it
    if len(root_items) == 1:
        result = reconstruct(root_items[0])
    else:
        # Multiple roots - join with commas
        result = ", ".join(reconstruct(item) for item in root_items)

    # A workaround needed since in the existing configurations
    #  generated by previous methods, e.g. the `resBlock resBlock` and `resBlock` items
    #  occur without wrapping parenthesis, differently from other items.
    # Wrap them appropriately in parentheses here and in the inverse process.
    # For example 'id' comes in two forms: 'id id' and 'Ops id',
    #  only the 'id id' variant should be replaced.
    replacements = [
        ("resBlock", True),
        ("id", False),
    ]
    for op, replace_individual in replacements:
        result = result.replace(f"({op} {op})", "__TMP_PLACEHOLDER___")
        if replace_individual:
            result = result.replace(f"({op})", f"{op}")
        result = result.replace("__TMP_PLACEHOLDER___", f"{op} {op}")
    return result


class ConfigString:
    """A class representing a configuration string in NePS spaces.
    It provides methods to unwrap the configuration string into structured parts,
    retrieve the maximum hierarchy level, and get a representation of the configuration
    at a specific hierarchy level.
    """

    def __init__(self, config_string: str) -> None:
        """Initialize the ConfigString with a given configuration string.

        Args:
            config_string: The configuration string to be wrapped.

        Raises:
            ValueError: If the config_string is None or empty.
        """
        if config_string is None or len(config_string) == 0:
            raise ValueError(f"Invalid config string: {config_string}")
        self.config_string = config_string

        # The fields below are needed for lazy and cached evaluation.
        # In python 3.8+ can be replaced by `cached_property`
        self._unwrapped: tuple[UnwrappedConfigStringPart, ...] | None = None
        self._max_hierarchy_level: int | None = None

        # a cache for the different hierarchy levels of this config string
        self._at_hierarchy_level_cache: dict[int, ConfigString] = {}

    @property
    def unwrapped(self) -> tuple[UnwrappedConfigStringPart, ...]:
        """Get the unwrapped representation of the configuration string.

        Returns:
            A tuple of UnwrappedConfigStringPart objects representing the unwrapped
            config.

        Raises:
            ValueError: If there is an error unwrapping the config string.
        """
        # If the unwrapped is already cached, return it
        if self._unwrapped is not None:
            return self._unwrapped

        unwrapped = unwrap_config_string(self.config_string)
        if not unwrapped:
            raise ValueError(f"Error unwrapping config string: {self.config_string}")

        # NOTE: Previously, here was a test that compared wrap_config_into_string
        # (unwrapped_config=unwrapped) to unwrapped. As it frequently failed and was
        # deemed to be unnecessary, it was removed

        self._unwrapped = unwrapped
        return self._unwrapped

    @property
    def max_hierarchy_level(self) -> int:
        """Get the maximum hierarchy level of the configuration string.

        Returns:
            The maximum hierarchy level of the configuration string.

        Raises:
            ValueError: If the maximum hierarchy level is invalid.
        """
        if self._max_hierarchy_level is not None:
            return self._max_hierarchy_level

        max_hierarchy_level = max(i.level for i in self.unwrapped)
        assert max_hierarchy_level > 0, (
            f"Invalid max hierarchy level: {self.max_hierarchy_level}"
        )

        self._max_hierarchy_level = max_hierarchy_level
        return self._max_hierarchy_level

    def at_hierarchy_level(self, level: int) -> ConfigString:
        """Get the configuration string at a specific hierarchy level.

        Args:
            level: The hierarchy level to retrieve the configuration string for.

        Returns:
            A ConfigString object representing the configuration at the specified
            hierarchy level.

        Raises:
            ValueError: If the level is invalid (0 or out of bounds).
        """
        if level == 0:
            raise ValueError(f"Invalid value for `level`. Received level == 0: {level}")
        if level > self.max_hierarchy_level:
            raise ValueError(
                "Invalid value for `level`. "
                + f"level>max_hierarchy_level: {level}>{self.max_hierarchy_level}"
            )
        if level < -self.max_hierarchy_level:
            raise ValueError(
                "Invalid value for `level`. "
                + f"level<-max_hierarchy_level: {level}<-{self.max_hierarchy_level}"
            )

        if level < 0:
            # for example for level=-1, when max_hierarchy_level=7, new level is 7
            # for example for level=-3, when max_hierarchy_level=7, new level is 5
            level = self.max_hierarchy_level + (level + 1)

        if level in self._at_hierarchy_level_cache:
            return self._at_hierarchy_level_cache[level]

        config_string_at_hierarchy_level = wrap_config_into_string(
            unwrapped_config=self.unwrapped, max_level=level
        )
        config_at_hierarchy_level = ConfigString(config_string_at_hierarchy_level)
        self._at_hierarchy_level_cache[level] = config_at_hierarchy_level

        return self._at_hierarchy_level_cache[level]

    def pretty_format(self) -> str:
        """Get a pretty formatted string representation of the configuration string.

        Returns:
            A string representation of the configuration string with indentation
            based on the hierarchy level of each part.
        """
        format_str_with_kwargs = (
            "{indent}{item.level:0>2d} :: {item.operator} {item.hyperparameters}"
        )
        format_str_no_kwargs = "{indent}{item.level:0>2d} :: {item.operator}"
        lines = [self.config_string]
        for item in self.unwrapped:
            if item.hyperparameters not in {"{}", ""}:
                line = format_str_with_kwargs.format(item=item, indent="\t" * item.level)
            else:
                line = format_str_no_kwargs.format(item=item, indent="\t" * item.level)
            lines.append(line)
        return "\n".join(lines)

    def __eq__(self, other: object) -> bool:
        if isinstance(other, self.__class__):
            return self.config_string == other.config_string
        raise NotImplementedError()  # let the other side check for equality

    def __ne__(self, other: object) -> bool:
        return not self.__eq__(other)

    def __hash__(self) -> int:
        return self.config_string.__hash__()
